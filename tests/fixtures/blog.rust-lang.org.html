<p>The Rust team is happy to announce a new version of Rust, 1.68.0. Rust is a programming language empowering everyone to build reliable and efficient software.</p> <p>If you have a previous version of Rust installed via rustup, you can get 1.68.0 with:</p> <pre><code class="language-console">rustup update stable </code></pre> <p>If you don't have it already, you can <a href="https://www.rust-lang.org/install.html">get <code>rustup</code></a> from the appropriate page on our website, and check out the <a href="https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1680-2023-03-09">detailed release notes for 1.68.0</a> on GitHub.</p> <p>If you'd like to help us out by testing future releases, you might consider updating locally to use the beta channel (<code>rustup default beta</code>) or the nightly channel (<code>rustup default nightly</code>). Please <a href="https://github.com/rust-lang/rust/issues/new/choose">report</a> any bugs you might come across!</p> <h2><a href="#whats-in-1680-stable" aria-hidden="true" class="anchor" id="whats-in-1680-stable"></a>What's in 1.68.0 stable</h2> <h3><a href="#cargos-sparse-protocol" aria-hidden="true" class="anchor" id="cargos-sparse-protocol"></a>Cargo's sparse protocol</h3> <p>Cargo's &quot;sparse&quot; registry protocol has been stabilized for reading the index of crates, along with infrastructure at <code>https://index.crates.io/</code> for those published in the primary crates.io registry. The prior git protocol (which is still the default) clones a repository that indexes <em>all</em> crates available in the registry, but this has started to hit scaling limitations, with noticeable delays while updating that repository. The new protocol should provide a significant performance improvement when accessing crates.io, as it will only download information about the subset of crates that you actually use.</p> <p>To use the sparse protocol with crates.io, set the environment variable <code>CARGO_REGISTRIES_CRATES_IO_PROTOCOL=sparse</code>, or edit your <a href="https://doc.rust-lang.org/cargo/reference/config.html"><code>.cargo/config.toml</code> file</a> to add:</p> <pre><code class="language-toml">[registries.crates-io] protocol = &quot;sparse&quot; </code></pre> <p>The sparse protocol is currently planned to become the default for crates.io in the 1.70.0 release in a few months. For more information, please see the prior <a href="https://blog.rust-lang.org/inside-rust/2023/01/30/cargo-sparse-protocol.html">announcement</a> on the Inside Rust Blog, as well as <a href="https://rust-lang.github.io/rfcs/2789-sparse-index.html">RFC 2789</a> and the current <a href="https://doc.rust-lang.org/stable/cargo/reference/registry-index.html#sparse-protocol">documentation</a> in the Cargo Book.</p> <h3><a href="#local-pin-construction" aria-hidden="true" class="anchor" id="local-pin-construction"></a>Local <code>Pin</code> construction</h3> <p>The new <a href="https://doc.rust-lang.org/stable/std/pin/macro.pin.html"><code>pin!</code></a> macro constructs a <code>Pin&lt;&amp;mut T&gt;</code> from a <code>T</code> expression, anonymously captured in local state. This is often called stack-pinning, but that &quot;stack&quot; could also be the captured state of an <code>async fn</code> or block. This macro is similar to some crates, like <a href="https://docs.rs/tokio/1/tokio/macro.pin.html"><code>tokio::pin!</code></a>, but the standard library can take advantage of <code>Pin</code> internals and <a href="https://doc.rust-lang.org/stable/reference/destructors.html#temporary-lifetime-extension">temporary lifetime extension</a> for a more expression-like macro.</p> <pre><code class="language-rust">/// Runs a future to completion. fn block_on&lt;F: Future&gt;(future: F) -&gt; F::Output { let waker_that_unparks_thread = todo!(); let mut cx = Context::from_waker(&amp;waker_that_unparks_thread); // Pin the future so it can be polled. let mut pinned_future = pin!(future); loop { match pinned_future.as_mut().poll(&amp;mut cx) { Poll::Pending =&gt; thread::park(), Poll::Ready(result) =&gt; return result, } } } </code></pre> <p>In this example, the original <code>future</code> will be moved into a temporary local, referenced by the new <code>pinned_future</code> with type <code>Pin&lt;&amp;mut F&gt;</code>, and that pin is subject to the normal borrow checker to make sure it can't outlive that local.</p> <h3><a href="#default-alloc-error-handler" aria-hidden="true" class="anchor" id="default-alloc-error-handler"></a>Default <code>alloc</code> error handler</h3> <p>When allocation fails in Rust, APIs like <code>Box::new</code> and <code>Vec::push</code> have no way to indicate that failure, so some divergent execution path needs to be taken. When using the <code>std</code> crate, the program will print to <code>stderr</code> and abort. As of Rust 1.68.0, binaries which include <code>std</code> will continue to have this behavior. Binaries which do not include <code>std</code>, only including <code>alloc</code>, will now <code>panic!</code> on allocation failure, which may be further adjusted via a <code>#[panic_handler]</code> if desired.</p> <p>In the future, it's likely that the behavior for <code>std</code> will also be changed to match that of <code>alloc</code>-only binaries.</p> <h3><a href="#stabilized-apis" aria-hidden="true" class="anchor" id="stabilized-apis"></a>Stabilized APIs</h3> <ul> <li><a href="https://doc.rust-lang.org/stable/std/pin/macro.pin.html"><code>{core,std}::pin::pin!</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/primitive.f32.html#impl-From%3Cbool%3E-for-f32"><code>impl From&lt;bool&gt; for {f32,f64}</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/path/constant.MAIN_SEPARATOR_STR.html"><code>std::path::MAIN_SEPARATOR_STR</code></a></li> <li><a href="https://doc.rust-lang.org/stable/std/path/struct.PathBuf.html#impl-DerefMut-for-PathBuf"><code>impl DerefMut for PathBuf</code></a></li> </ul> <p>These APIs are now stable in const contexts:</p> <ul> <li><a href="https://doc.rust-lang.org/stable/std/collections/struct.VecDeque.html#method.new"><code>VecDeque::new</code></a></li> </ul> <h3><a href="#other-changes" aria-hidden="true" class="anchor" id="other-changes"></a>Other changes</h3> <ul> <li>As <a href="https://blog.rust-lang.org/2023/01/09/android-ndk-update-r25.html">previously announced</a>, Android platform support in Rust is now targeting NDK r25, which corresponds to a minimum supported API level of 19 (KitKat).</li> </ul> <p>Check out everything that changed in <a href="https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1680-2023-03-09">Rust</a>, <a href="https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-168-2023-03-09">Cargo</a>, and <a href="https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-168">Clippy</a>.</p> <h3><a href="#contributors-to-1680" aria-hidden="true" class="anchor" id="contributors-to-1680"></a>Contributors to 1.68.0</h3> <p>Many people came together to create Rust 1.68.0. We couldn't have done it without all of you. <a href="https://thanks.rust-lang.org/rust/1.68.0/">Thanks!</a></p>